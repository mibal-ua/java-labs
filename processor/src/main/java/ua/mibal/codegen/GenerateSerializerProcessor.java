package ua.mibal.codegen;

import ua.mibal.codegen.api.GenerateSerializer;
import ua.mibal.codegen.api.Serialize;
import ua.mibal.codegen.util.ReflectionUtils;

import javax.annotation.processing.AbstractProcessor;
import javax.annotation.processing.RoundEnvironment;
import javax.annotation.processing.SupportedAnnotationTypes;
import javax.annotation.processing.SupportedSourceVersion;
import javax.lang.model.element.Element;
import javax.lang.model.element.TypeElement;
import java.io.IOException;
import java.io.PrintWriter;
import java.util.List;
import java.util.Map;
import java.util.Set;

import static javax.lang.model.SourceVersion.RELEASE_17;

/**
 * Annotation Processor that generates serializers for classes annotated with
 * {@link GenerateSerializer} and {@link Serialize} annotations.
 * <p>
 * This processor generates a serializer class that implements methods for
 * serializing objects into JSON and XML formats based on reflection of the
 * annotated model classes.
 * </p>
 *
 * <p>
 * It will generate methods like:
 * <ul>
 * <li>{@code String json(Object object)}</li>
 * <li>{@code String xml(Object object)}</li>
 * </ul>
 * </p>
 *
 * @author Mykhailo Balakhon
 * @link <a href="mailto:mykhailo.balakhon@communify.us">mykhailo.balakhon@communify.us</a>
 */
@SupportedAnnotationTypes({
        "ua.mibal.codegen.api.GenerateSerializer",
        "ua.mibal.codegen.api.Serialize"
})
@SupportedSourceVersion(RELEASE_17)
public class GenerateSerializerProcessor extends AbstractProcessor {

    /**
     * Processes the annotations {@link GenerateSerializer} and {@link Serialize}.
     * It generates a stub serializer for each class annotated with {@link GenerateSerializer}
     * and serializes fields of models annotated with {@link Serialize}.
     *
     * @param annotations the set of annotations encountered during this round
     * @param roundEnv    the environment for this round of annotation processing
     * @return {@code true} if the annotations were processed, otherwise {@code false}
     */
    @Override
    public boolean process(Set<? extends TypeElement> annotations,
                           RoundEnvironment roundEnv) {
        Set<? extends Element> models =
                roundEnv.getElementsAnnotatedWith(Serialize.class);
        roundEnv.getElementsAnnotatedWith(GenerateSerializer.class).forEach(serializer ->
                generateStubSerializerFor(serializer, models)
        );
        return true;
    }

    /**
     * Generates the implementation of the serializer for a class annotated with {@link GenerateSerializer}.
     *
     * @param serializer the serializer interface to be implemented
     * @param models     the set of model classes annotated with {@link Serialize}
     */
    private void generateStubSerializerFor(Element serializer, Set<? extends Element> models) {
        String serializerIClassName = serializer.getSimpleName().toString();
        String serializerImplName = serializerIClassName + "Impl";
        String packageName = serializer.getEnclosingElement().toString();

        Map<Element, List<? extends Element>> fieldsOfModels = ReflectionUtils.getFieldMappings(models);

        try (PrintWriter writer = new PrintWriter(
                processingEnv.getFiler().createSourceFile(packageName + "." + serializerImplName).openWriter())) {
            writer.println("""
                    package %s;
                    
                    import %s;
                    
                    /**
                     * Autogenerated Serializer by GenerateSerializerProcessor
                     *
                     * @author Mykhailo Balakhon
                     * @link <a href="mailto:mykhailo.balakhon@communify.us">mykhailo.balakhon@communify.us</a>
                     */
                    public class %s implements %s {
                    """.formatted(packageName, packageName + "." + serializerIClassName, serializerImplName, serializerIClassName)
            );

            generateJsonRouter(writer, fieldsOfModels);
            generateXmlRouter(writer, fieldsOfModels);

            fieldsOfModels.forEach((className, fields) -> {
                writer.println(generateJsonMethod(className, fields));
                writer.println(generateXmlMethod(className, fields));
            });

            writer.println("}\n");
        } catch (IOException e) {
            throw new RuntimeException(e);
        }
    }

    /**
     * Generates the JSON serialization router method.
     *
     * @param writer         the writer used to write the generated code
     * @param fieldsOfModels the mapping of model elements and their fields
     */
    private void generateJsonRouter(PrintWriter writer, Map<Element, List<? extends Element>> fieldsOfModels) {
        writer.println("\tpublic String json(Object object) {");
        fieldsOfModels.forEach((element, fields) -> {
            String className = ReflectionUtils.extractClassName(element);
            writer.println(("\t\tif (object instanceof %s) {\n" +
                            "\t\t\treturn mapJson((%s) object);\n" +
                            "\t\t}").formatted(className, className)
            );
        });
        writer.println("\t\tthrow new IllegalArgumentException(\"Mapping for this class \" + object.getClass().getName() + \" is not declared!\");\n" +
                       "\t}\n");
    }

    /**
     * Generates the XML serialization router method.
     *
     * @param writer         the writer used to write the generated code
     * @param fieldsOfModels the mapping of model elements and their fields
     */
    private void generateXmlRouter(PrintWriter writer, Map<Element, List<? extends Element>> fieldsOfModels) {
        writer.println("\tpublic String xml(Object object) {");
        fieldsOfModels.forEach((element, fields) -> {
            String className = ReflectionUtils.extractClassName(element);
            writer.println(("\t\tif (object instanceof %s) {\n" +
                            "\t\t\treturn mapXml((%s) object);\n" +
                            "\t\t}").formatted(className, className)
            );
        });
        writer.println("\t\tthrow new IllegalArgumentException(\"Mapping for this class \" + object.getClass().getName() + \" is not declared!\");\n" +
                       "\t}\n");
    }

    /**
     * Generates the JSON mapping method for a model class.
     *
     * @param clazz  the model class element
     * @param fields the fields of the model class
     * @return the generated JSON method as a string
     */
    private String generateJsonMethod(Element clazz, List<? extends Element> fields) {
        StringBuilder methodBuilder = new StringBuilder();

        String className = ReflectionUtils.extractClassName(clazz);
        methodBuilder.append("\tprivate String mapJson(%s o) {\n".formatted(className));
        methodBuilder.append("\t\treturn \"{\" +\n");

        for (Element field : fields) {
            String getter = ReflectionUtils.getGetterName(field);
            String propertyName = ReflectionUtils.getPropertyName(field);
            String fieldType = field.asType().toString();

            if (String.class.getName().equals(fieldType)) {
                methodBuilder.append("""
                        \t\t\t"\\"%s\\": \\"" + o.%s() + "\\"" + "," +
                        """.formatted(propertyName, getter));
            } else {
                methodBuilder.append("""
                        \t\t\t"\\"%s\\": " + o.%s() + "," +
                        """.formatted(propertyName, getter));
            }
        }
        methodBuilder.delete(methodBuilder.length() - 6, methodBuilder.length() - 1);
        methodBuilder.append("\t\t\"}\";\n");
        methodBuilder.append("\t}\n");
        return methodBuilder.toString();
    }

    /**
     * Generates the XML mapping method for a model class.
     *
     * @param clazz  the model class element
     * @param fields the fields of the model class
     * @return the generated XML method as a string
     */
    private String generateXmlMethod(Element clazz, List<? extends Element> fields) {

        StringBuilder methodBuilder = new StringBuilder();
        String className = ReflectionUtils.extractClassName(clazz);

        Serialize xmlModelName = clazz.getAnnotation(Serialize.class);
        String modelName = xmlModelName.value().isEmpty()
                ? lowerCaseFirstLetter(clazz.getSimpleName().toString())
                : xmlModelName.value();

        methodBuilder.append("\tprivate String mapXml(%s o) {\n".formatted(className));
        methodBuilder.append("\t\treturn \"<%s>\" +\n".formatted(modelName));

        for (Element field : fields) {
            String getter = ReflectionUtils.getGetterName(field);
            String propertyName = ReflectionUtils.getPropertyName(field);

            methodBuilder.append("""
                    \t\t\t"<%s>" + o.%s() + "</%s>" +
                    """.formatted(propertyName, getter, propertyName));
        }
        methodBuilder.append("\t\t\t \"</%s>\";\n".formatted(modelName));
        methodBuilder.append("\t}\n");
        return methodBuilder.toString();
    }

    /**
     * Converts the first letter of the provided string to lowercase.
     *
     * @param simpleName the string to modify
     * @return the modified string with the first letter in lowercase
     */
    private String lowerCaseFirstLetter(String simpleName) {
        return simpleName.substring(0, 1).toLowerCase() + simpleName.substring(1);
    }
}
